= Nginx directive execution order (02) =

We've just learnt, all L<ngx_rewrite/set> commands within C<location>
are executed in C<rewrite> phase. In fact, almost all commands implemented
by module C<rewrite> are executed in C<rewrite> phase under the specific
context. Commad L<ngx_rewrite/rewrite> introduced in
L<vartut/Nginx Variables (02)>
is one of them. However, we shall point out that when these commands are
found in C<server> directive, they will be executed in an earlier phase
we've not
addressed: the C<server rewrite> phase.

Command L<ngx_set_misc/set_unescape_uri>, introduced in L<vartut/Nginx
Variables (02)>
is also executed in C<rewrite> phase. Actually, commands implemented by
module
L<ngx_set_misc> can mix with commands implemented by module L<ngx_rewrite>
and the execution ordering is ensured. Let's check an example:

    :nginx
    location /test {
        set $a "hello%20world";
        set_unescape_uri $b $a;
        set $c "$b!";

        echo $c;
    }

By sending a request accordingly we have:

    :bash
    $ curl 'http://localhost:8080/test'
    hello world!

Apparently, the L<ngx_set_misc/set_unescape_uri> command and its
neighboring L<ngx_rewrite/set> commands are all executed in the order
of their writing.

To further demonstrate our assertion, we check again Nginx "debug log"
(in case it's unclear for you how to check "debug log", please reference
steps found in L<ordertut/ (01)>).

    :bash
    grep -E 'http script (value|copy|set)' logs/error.log

The debug logs are filtered as:

    :text
    [debug] 11167#0: *1 http script value: "hello%20world"
    [debug] 11167#0: *1 http script set $a
    [debug] 11167#0: *1 http script value (post filter): "hello world"
    [debug] 11167#0: *1 http script set $b
    [debug] 11167#0: *1 http script copy: "!"
    [debug] 11167#0: *1 http script set $c

The leading two lines:

    :text
    [debug] 11167#0: *1 http script value: "hello%20world"
    [debug] 11167#0: *1 http script set $a

They correspond to the command

    :nginx
    set $a "hello%20world";

The following two lines:

    :text
    [debug] 11167#0: *1 http script value (post filter): "hello world"
    [debug] 11167#0: *1 http script set $b

They are generated by command

    :nginx
    set_unescape_uri $b $a;

There are minor differences in the first line, if we compare to the logs
generated by command L<ngx_rewrite/set>: the C<"(post filter)"> addition.
In the end of the line, URL decoding has successfully executed as we wish.
C<"hello%20world"> is decoded as C<"hello world">.

The last two lines of debug log:

    :text
    [debug] 11167#0: *1 http script copy: "!"
    [debug] 11167#0: *1 http script set $c

They are generated by the last L<ngx_rewrite/set> command

    :nginx
    set $c "$b!";

As you might have noticed, since "variable interpolation" is evaluated
when variable C<$c> is declared and initialized, the debug log starts
with C<http script copy>. In the end of the log it is the string constant
C<"!"> to be concatenated.

With the log information, it's fairly easy to tell the command execution
ordering:

    :nginx
    set $a "hello%20world";
    set_unescape_uri $b $a;
    set $c "$b!";

It is a perfect match to the statements ordering.

Just like the commands implemented in module L<ngx_set_misc>, command
L<ngx_lua/set_by_lua> implemented in 3rd party module L<ngx_lua>, can mix
with
commands of module L<ngx_rewrite> as well. As introduced in
L<vartut/Nginx Variables (07)>, command L<ngx_lua/set_by_lua> supports
computation with given Lua code, and assigns the computed result to a Nginx
variable. As command L<ngx_rewrite/set> does, command L<ngx_lua/set_by_lua>
declares Nginx variable before initialization if the variable does not
exist.

Let's check a mixed example which comprises command L<ngx_lua/set_by_lua>
and L<ngx_rewrite/set>:

    :nginx
    location /test {
        set $a 32;
        set $b 56;
        set_by_lua $c "return ngx.var.a + ngx.var.b";
        set $equation "$a + $b = $c";

        echo $equation;
    }

Variable C<$a> and C<$b> are initialized with numerical value C<32>
and C<56> respectively, then command L<ngx_lua/set_by_lua> is used
together with given Lua code to compute the sum of C<$a> and C<$b>.
Variable C<$c> is initialized with the computed value. Finally,
variables C<$a>, C<$b> and C<$c> are concatenated by "variable interpolation"
and assigns the result to variable C<$equation>, which is printed by
command L<ngx_echo/echo>.

We shall pay attention to a few points in the example: Firstly
Nginx variable C<$VARIABLE> is referenced as L<ngx_lua/ngx.var.VARIABLE>
in Lua code. Secondly, since Nginx variables are strings, the
value of variable C<ngx.var.a> and C<ngx.var.b> are actually strings
C<"32"> and C<"56">, however they are automatically converted to numerical
values by Lua in the addition operation. Thirdly Lua code returns
to Nginx variable C<$c> the computed sum value by statement C<return>.
Finally when Lua code returns, it actually converts the numerical value
back to string. (because string is the only valid value for Nginx variable)

The actual output meets our expectation:

    :bash
    $ curl 'http://localhost:8080/test'
    32 + 56 = 88

This in fact asserts that command L<ngx_lua/set_by_lua> can mix with
commands implemented by module L<ngx_rewrite>, such as L<ngx_rewrite/set>.

Many other 3rd party modules support the mix with module L<ngx_rewrite>
as well. The examples include module L<ngx_array_var>, discussed in
L<vartut/Nginx Variables (08)> and module L<ngx_encrypted_session>, which
encrypts sessions. The latter will be studied in detail shortly.

Since builtin module L<ngx_rewrite> is virtually indispensable, it's
a great advantage for the 3rd party module has the caliber of being
mixed with. Truth is, all of those 3rd party modules have adopted
a special technique, which allows the "injection" of their execution
into commands of module C<rewrite> (with the help of a 3rd party module
L<ngx_devel_kit> developed by Marcus Clyne). For the rest regular 3rd
party modules, which also register their execution in phase C<rewrite>,
their commands are executed separately from module L<ngx_rewrite> in runtime.
In fact, it's hardly accurate to tell the commands execution ordering
in between different modules (strictly speaking they are usually executed
in the order of loading, but exception does exist). For example both
modules, C<A> and C<B> register their commands to be executed in phase
C<rewrite>, then it is either the case in which commands of C<A> are executed
followed by C<B> or the other complete way around. Unless it is explicitly
documented, we cannot rely on the uncertain ordering in our configurations.

