= Nginx directive execution order (07) =

Let's check an example in which module L<ngx_static> serves
disk files, with following configuration snippet:

    :nginx
    location / {
        root /var/www/;
    }

Meanwhile two files are created under F</var/www/>. One
file is named F<index.html> and its content contains one line of
text C<this is my home>. Another file is named F<hello.html>
and its content contains one line of text C<hello world>. Again
be aware of the files' privileges and make sure they are
readable by Nginx worker process.

Now we send requests to the files' corresponding URI:

    :bash
    $ curl 'http://localhost:8080/index.html'
    this is my home

    $ curl 'http://localhost:8080/hello.html'
    hello world

As we can see, the created file contents are sent as outputs.

We can examine what is happening here: C<location /> does not
have any command to execute in phase C<content>, therefore no
module has registered a "content handler" in the C<location>.
The handling thus falls to the three static resource modules
which are the last resorts of phase C<content>. The former two
modules L<ngx_index> and L<ngx_autoindex> notices that the request
URI does not end with C</> so they hand off immediately to module
L<ngx_static>, which runs in the end. According to the "document
root" specified by command L<ngx_core/root>, module L<ngx_static>
maps the request URIs C</index.html> and C</hello.html> to disk
files F</var/www/index.html> and F</var/www/hello.html> respectively.
As both files can be found, their content are outputted as response,
meanwhile response header C<Content-Type>, C<Content-Length> and
C<Last-Modified> are accordingly indicated.

To verify module L<ngx_static> has executed, we could enable the
"debug log" introduced in L<ordertut/ (01)>. Again we send request
to C</index.html> and Nginx error log will contain following
debug information:

    :text
    [debug] 3033#0: *1 http static fd: 8

This line is generated by module L<ngx_static>. Its meaning is "
outputting static resource whose file handle is C<8>". Of course
the numerical file handle changes every time, and the line is
only a typical output in my setup. To be reminded, builtin module
L<ngx_gzip_static> could generate the same debug info as well,
by default it is not enabled though, which will be discussed later.

Command L<ngx_core/root> only declares a "document root", it does not
enables the L<ngx_static> module. The module is as matter of fact, always
enabled already, but it might not have the chance to execute. This is
entirely up to the other modules, which execute earlier in C<content> phase.
Module L<ngx_static> execute only when all of them have "gave up". To
prove this, check following blank C<location> definition:

    :nginx
    location / {
    }

Because there is no L<ngx_core/root> command, Nginx computes
a default "document root" when the location is requested. The default
shall be the F<html/> subdirectory under "configure prefix". For example
suppose our "configure prefix" is F</foo/bar/>, the default "document
root" is F</foo/bar/html/>.

So who decides "configure prefix" ? Actually it the Nginx root
directory when it is installed (or the value of C<--prefix> option of
script F<./configure> when Nginx is built). If Nginx is installed into
C</usr/local/nginx/>, "configure prefix" is C</usr/local/nginx/> and
default "document root" is therefore C</usr/local/nginx/html/>. Certainly
a command line option C<--prefix> can be given when Nginx is started,
to change the "configure prefix" (so that we can easily test multiple
setups). Suppose Nginx is started as following:

    :bash
    nginx -p /home/agentzh/test/

For this server, its "configure prefix" becomes F</home/agentzh/test/>
and its "document root" becomes F</home/agentzh/test/html/>. The "configure
prefix" not only determines "document root", it actually determines
the way many relational path resolutes to absolute path in Nginx configuration.
We will encounter many examples which reference "configure prefix".

In fact there is a simple way of telling current "document root", which
is
to request a non-existed file, Such as:

    :nginx
    $ curl 'http://localhost:8080/blah-blah.txt'
    <html>
    <head><title>404 Not Found</title></head>
    <body bgcolor="white">
    <center><h1>404 Not Found</h1></center>
    <hr><center>nginx</center>
    </body>
    </html>

Naturally, the C<404> error page is returned. Again when we check
Nginx error log, we shall have following error message:

    :text
    [error] 9364#0: *1 open() "/home/agentzh/test/html/blah-blah.txt" failed (2: No such file or directory)

The error message is printed by module L<ngx_static>, since it cannot
find a file F<blah-blah.txt> in its corresponding path. And because
the error message contains the absolute path, which L<ngx_static>
attempts to open with, it's quite obvious that current "document root"
is F</home/agentzh/test/html/>.

Many newbies might take it for granted that error C<404> is caused when
the needed C<location> does not exist. The former example tells us,
C<404> error could be returned even if the needed C<location> is configured
and matched. This is because error C<404> means the non-existence of a
abstract "resource", not the specific C<location>.

Another frequent mistake is missing the command for phase C<content>,
when they actually don't expect the default static modules to come into
play,for example:

    :nginx
    location /auth {
        access_by_lua '
            -- a lot of Lua code omitted here...
        ';
    }

Apparently,  only commands for phase C<access> are given for F</auth>,
which is L<ngx_lua/access_by_lua>. And it has no commands for phase C<content>.
So when C</auth> is requested, the Lua code specified in C<access> phase
will execute, then the static resource will be served in phase C<content>
by module L<ngx_static>. Since it actually looks for the file F</auth>
on the disk
normally it dumps a C<404> error unless we are luckily and file F</auth>
is created on the corresponding path. So the thumb of rule, when error
C<404> is encountered under no static resource circumstances, we shall
first check if the C<location> has properly configured its commands for
phase C<content>, the commands can be L<ngx_lua/content_by_lua>,
L<ngx_echo/echo> and L<ngx_proxy/proxy_pass> etc. In fact, Nginx error
log
F<error.log> could only give very confusing message for the case. As the
ones below, which is found for the above example:

    :text
    [error] 9364#0: *1 open() "/home/agentzh/test/html/auth" failed (2: No such file or directory)

