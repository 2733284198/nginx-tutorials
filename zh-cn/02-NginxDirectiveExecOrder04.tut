= Nginx 配置指令的执行顺序（四） =

L<ngx_lua> 模块在 C<access> 请求处理阶段提供了配置指令 L<ngx_lua/access_by_lua>，
用于内联用户 Lua 代码在 C<access> 阶段的末尾执行。这条指令因为
运行于 C<access> 阶段的末尾，所以总是运行在 L<ngx_access/allow>
和 L<ngx_access/deny> 这样的指令之后，虽然它们同属 C<access>
阶段。一般我们通过 L<ngx_lua/access_by_lua> 在 L<ngx_access>
模块检查过客户端 IP 地址之后，再通过 Lua 代码执行一系列更复杂的请求验证
操作，比如实时地查询后端数据库或者其他存储，以验证当前用户的身份或权限。

我们来看一个简单的例子，利用 L<ngx_lua/access_by_lua>
来实现 L<ngx_access> 模块的 IP 地址过滤功能：

    :nginx
    location /hello {
        access_by_lua '
            if ngx.var.remote_addr == "127.0.0.1" then
                return
            end

            ngx.exit(403)
        ';

        echo "hello world";
    }

这里我们在　Lua 代码中通过引用 Nginx 标准的内建变量 L<ngx_core/$remote_addr>
来获取当前客户端的字符串形式的 IP 地址，然后我们用 Lua 的 C<if>
语句判断该地址是否为本机地址，即　C<127.0.0.1>. 如果是本机地址，则
直接利用 Lua 的 C<return> 语句返回，让 Nginx 继续执行后续
的请求处理阶段（包括 L<ngx_echo/echo> 指令所处的 C<content>
阶段）。而如果不是本机地址，则通过 L<ngx_lua> 模块提供的 Lua 函
数 L<ngx_lua/ngx.exit> 直接中断当前的整个请求处理流程，直接
返回 C<403> 错误页给客户端。

这个例子在功能上完全等价于我们先前在 L<ordertut/（三）> 中介绍过的
那个使用 L<ngx_access> 模块的例子：

    :nginx
    location /hello {
        allow 127.0.0.1;
        deny all;

        echo "hello world";
    }

虽然这两个例子在功能上完全相同，但在性能上还是有微小区别的，毕竟 L<ngx_access>
是用纯 C 实现的专门化的 Nginx 模块。

下面我们不妨来实际测量一下这两个例子的性能差别，毕竟我们使用 Nginx 就是为
了追求高性能。对于量化的性能比较，在工程上具有重大的现实意义，所以我们顺便介绍一
些常用的测量技术。由于无论是 L<ngx_access> 还是 L<ngx_lua>
在进行 IP 地址验证方面的性能都非常高，所以为了减少测试误差，我们希望能直接对
Nginx 的 C<access> 请求处理阶段的实际用时进行直接测量。为了做
到这一点，传统的做法一般会涉及到修改 Nginx 源码，自己插入专门的计时代码和
统计输出代码，抑或是重新编译 Nginx 以启用像 C<GNU gprof> 这
样专门的性能监测工具。幸运的是，在新一点的 Solaris, Mac OS X,
以及 FreeBSD 等系统上存在一个叫做 C<dtrace> 的工具，可以对任
意的用户程序进行微观性能分析，而无须对用户程序的源码进行修改或者以特殊的编译器和
链接器选项进行重新编译和链接。

为方便起见，下面在我的 MacBook Air 笔记本上演示一下这里的测量过程。
我的苹果本上的系统 Mac OS X 10.6 自带了 C<dtrace> 工具
（事实
上，而从 Mac OS X 10.5 "Leopard" 开始就自带了）。

首先，在我的 Mac OS X 系统中打开一个命令行终端，在某一个文件目录下面创
建一个名为 F<nginx-access-time.d> 的文件，并编辑内容如下
：

    :d
    #!/usr/bin/env dtrace -s

    pid$1::ngx_http_handler:entry
    {
        elapsed = 0;
    }

    pid$1::ngx_http_core_access_phase:entry
    {
        begin = timestamp;
    }

    pid$1::ngx_http_core_access_phase:return
    /begin > 0/
    {
        elapsed += timestamp - begin;
        begin = 0;
    }

    pid$1::ngx_http_finalize_request:return
    /elapsed > 0/
    {
        @elapsed = avg(elapsed);
        elapsed = 0;
    }

保存好此文件后，再赋予它可执行权限：

    :bash
    $ chmod +x ./nginx-access-time.d

这个 F<.d> 文件中的代码是用 C<dtrace> 工具自己提供的 C<D>
语言来编写的
（注意，这里的 C<D> 语言并不是由 Walter Bright 作为另一种“
更好的 C++”而设计的 C<D> 语言）。由于本系列教程并不打算介绍如何编写
C<dtrace> 的 C<D> 脚本，同时理解这个脚本需要不少有关 Nginx
内部源码实现的细节，所以这里我并不打算介绍该脚本的实现细节和
原理。大家只需要知道这个脚本的功能是用来统计指定的 Nginx worker 进
程在处理每个请求时，平均花费在 C<access> 请求处理阶段上的时间。

现在来演示一下这个 C<D> 脚本的运行方法。这个脚本接受一个命令行参数用于指定
监视的 Nginx worker 进程的进程号（pid）。由于 Nginx 支持
多 worker 进程，所以我们测试时发起的 HTTP 请求可能由其中任一 worker
进程所服务。为了确保所有测试请求都为固定的 worker 进程服务，我们需要在
F<nginx.conf> 配置文件中配置成只启用一个 worker 进程：

    :nginx
    worker_processes 1;

重启 Nginx 服务器之后，我们可以利用 C<ps> 命令得到当前 worker
进程的进程号：

    :bash
    $ ps ax|grep nginx|grep worker|grep -v grep

在我机器上的一次典型输出是

    :text
    10975   ??  S      0:34.28 nginx: worker process

其中第一列的数值便是我的 nginx worker 进程的进程号。当然，一旦重启
Nginx 服务器或者让 Nginx 重新加载配置，该进程号就会发生变化。如果你
得到的输出不止一行，则通常意味着你的系统中同时运行着多个 Nginx 服务器实例
，或者当前 Nginx 实例启用了多个 worker 进程。

接下来，我们使用刚刚得到的 worker 进程号以及 root 身份来运行我们先
前准备好的 C<D> 脚本：

    :bash
    # ./nginx-access-time.d 10975

如果一切正常，我们会看到这样一行输出：

    :text
    dtrace: script './nginx-access-time.d' matched 4 probes

这行输出是说，我们的 C<D> 脚本已成功向指定的 Nginx worker 进
程动态植入了 4 个 C<dtrace> “探针”（probe）。紧接着这个脚本
就挂起了，这表明 C<dtrace> 工具正在按照我们的 C<D>
脚本的指示，通过那 4 个“探针”，对进程号为 C<10975> 的 Nginx
worker 进程进行
监视。

然后我们再打开一个新终端，在那里使用 C<curl> 这样的工具多次请求我们正在
监视中的 Nginx 所服务的接口，最后我们回到原先那个一直在运行 C<D> 脚
本的终端，按下 <Ctrl-C> 组合键中止这个 C<D> 脚本的运行。而该脚本
在退出时会向终端打印出它的最终统计结果，例如我的终端是这个样子的：

    :bash
    # ./nginx-access-time.d 10975
    dtrace: script './nginx-access-time.d' matched 4 probes
    ^C
           19219

最后一行输出 C<19219> 便是那几次 C<curl> 发起的 HTTP 请
求在 C<access> 阶段的平均用时（以纳秒，即 10 的负 9 次方秒为单
位）。

通过上面介绍的步骤，我们可以通过我们的 F<nginx-access-time.d>
脚本分别统计和比较各种不同的 Nginx 配置下 C<access> 阶段的平均
用时。我们感兴趣的三种情况是：使用 L<ngx_access> 过滤 IP 地址
，使用 L<ngx_lua/access_by_lua> 过滤 IP 地址，以及
不在 C<access> 阶段使用任何配置指令。最后一种情况属于“空白对照组”，
可以用于校正测试过程中因 dtrace 探针本身等其他因素而引入的“系统误差”。
另外，为了最小化各种不可控的“随机误差”，我们可以采用 C<ab> 这样的批量
测试工具来取代 C<curl> 进行十万次以上的连续请求，这样我们的 C<D>
脚本统计出来的平均值可以更加接近“真实值”。

在我的苹果系统上，一次典型的测试结果如下：

    :text
    ngx_access 组              18146
    access_by_lua 组           35011
    空白对照组                 15887

我们把前两组的结果分别减去“空白对照组”的结果可以得到

    :text
    ngx_access 组               2259
    access_by_lua 组           19124

显然，L<ngx_access> 组比 L<ngx_lua/access_by_lua>
组快了大约一个数量级，这正是我们所预期的。不过其绝对时间差是极小的，对于我的 C<Intel
Core 2 Duo 1.86 GHz> 的 CPU 而言，只有区区十几微秒，或
者说十万分之一秒的量级。

