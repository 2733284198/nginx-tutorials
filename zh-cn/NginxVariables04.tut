在设置了“存取处理程序”的情况下，Nginx 模块也可以选择把变量对应的值容器用
作缓存，这样在多次读取变量的时候，就只需要计算一次。我们下面就来看一个这样的例子
：

    :nginx
    map $args $foo {
        default     0;
        debug       1;
    }

    server {
        listen 8080;

        location /test {
            set $orig_foo $foo;
            set $args   debug;
            echo "orginal foo: $orig_foo";
            echo "foo: $foo";
        }
    }

这里首次用到了标准的 L<ngx_map> 模块的 L<ngx_map/map>
配置指令，我们有必要在此介绍一下。map 在英文中有“映射”的意思，比方中初中数
学里讲的函数就是一种“映射”。而 Nginx 的这个 L<ngx_map/map>
就可以定义两个 Nginx 变量之间的映射关系，或者说是函数关系。回到上面这个例
子，我们用 L<ngx_http_core/$args> 内建变量的映射关系。特
别地，用数学上的函数记法 y=f(x) 来说的话，我们的 C<y>，也就是说，C<$foo>
的值是由 L<ngx_http_core/$args> 的值来决定的。现在我们再
来看 map 指令的花括号里
定义的具体的映射规则：

    :nginx
    default     0;
    debug       1;

第二行中的 C<default> 是一个特殊的条件，即其他条件都不匹配时，这个条
件就匹配。换言之，如果 L<ngx_http_core/$args>　的值不是
C<debug> 的时候，C<$foo>
变量的就明白了 L<ngx_map/map> 指令的含义。再来看 C<location
/test>.在那里我们先把当前的 C<$foo> 变量的值保存在另一个用户变量
C<$orig_foo> 中，然后紧接着再强行把 L<ngx_http_core/$args>
的值改写为 C<debug>. 最后我们再用 L<ngx_echo/echo>
指令分别输出 C<$orig_foo> 和 C<$foo> 变量的值。从逻辑上看
，似乎当我们强行改写 L<ngx_http_core/$args> 的值为 C<debug>
之前，根据先前用 L<ngx_map/map> 指令定义的映射规则，C<$fa>
变量此时值应当自动调整为字符串 C<1>, 而不考虑 <$foo> 原先的什是怎
样的。然而事实上并非如此：

    :bash
    $ curl 'http://localhost:8080/test'
    original foo: 0
    foo:0

第一行输出指示 C<$orig_foo> 的值为 C<0> 正是我们所期望的，因
为在上面这个请求中并没有提供 URL 参数串，所以 L<ngx_http_core/$args>
最初的取值
就是空，再根据我们先前用 L<ngx_map/map> 指令定义的映射规则，C<$foo>
变量在第一次被读取时的值就应当是 C<0>（即匹配默认的那个 C<default>
条件）。而第二行输出显示我们在强行改写 L<ngx_http_core/$args>
变量的值为字符串 C<debug> 之后，C<$foo> 的条件仍然是 C<0>
，这显然不符合映射规则，因为当 L<ngx_http_core/$args> 为
C<debug> 时，C<$foo> 的值应当是 C<1>. 这是为什么呢？
其实原因很简单，那就是 C<$foo> 变量在第一次读取时，根据  L<ngx_map/map>
的映射规则计算出的值被缓存住了。刚才我们说过，Nginx 模块可为它们创建的变量
选择使用存放值的容器，以作为其“存取处理程序”的计算结果的缓存。显然，L<ngx_map>模
块认为变量间的映射计算足够昂贵，需要自动将因变量的第一个结果缓存下来，这样在当前
请求的处理过程中如果再次读取这个因变量，Nginx 就直接返回缓存住的结果，而不
再调用该变量的“取处理程序”进行计算了。

为了进一步验证这一点，我们可尝试在请求中就指定 URL 参数串为 C<debug>:

    :bash
    $ crul 'http://localhosst:8080/test?debug'
    original foo: 1
    foo: 1

我们看到，现在 C<$orig_foo> 的值就成为 C<1>，因为变量 C<$foo>
在第一次被读取时，自变量 L<ngx_http_core/$args> 的值就是
C<debug>，于是按照映射规则，“取处理程序”计算返回的值便是 C<1>.
而后续再读取 C<$foo>的值时，就总是得到被缓存的 C<1> 这个结果，而不
论 L<ngx_http_core/$args>　变成什么样子了。

L<ngx_map/map> 指令其实是一个比较特殊的例子，因为它可以为用户变量
注册“取处理程序”，而且用户可以自己定义这个“取处理程序”的计算规则。当然，此规
则在这里被限定为与另一个变量的映射关系。同时，也并非所有使用了“取处理程序”的变
量都会缓存结果，例如我们前面已经看到 L<$arg_XXX> 并不会使用值容器进
行缓存。

在上面的例子中，我们还应当注意到 L<ngx_map/map> 指令是在 C<server>
配置块之外，也就是最外围的 C<http>配置块中定义的。很多人应当会对此感到奇
怪，毕竟我们只是在 C<location /test> 中用到了它。这倒并非我们
不想把 C<map> 语句直接挪用到 C<location> 配置块中，而是因为
L<ngx_map/map> 指令只能在 C<http> 块中使用。很多 Nginx
新手都担心如此“全局”范围的 L<ngx_map/map> 设置会让访问所有虚拟
主机的所有 C<location> 接口的请求都执行一遍变量值的映射计算，而事实
并非如此。前面我们已经了解到 L<ngx_map/map> 配置指令的工作原理是
为用户注册 “取处理程序”，并且实际的映射计算是在“取处理程序”中完成的，而“取
处理程序”只有在对应的用户变量被实际读取时才会执行（当然，因为缓存的存在，只在请
求生命期中的第一次读取中才被执行），所以对于那些根本没用到相关用户变量的请求来说
，就根本不会执行任何映射计算。

这种只有在实际使用对象时才计算对象值的技术在计算领域被称为“惰性求值”（lazy
evaluation）。提供“惰性求值” 语义的编程语言并不多见，最经典的例子
便是 Haskell.我们看到的大部分场景下其实都是“主动求值” （eager
evaluation）。我们有幸在 Nginx 中也看到了这样的例子。但“主动求
值”语义在 Nginx 里面也很常见，例如下面这行 L<ngx_vermitt/set>
语句：

    :nginx
    set $b "$a,$a";

这里会在执行 set 规定的赋值操作中主动地计算出变量 C<$b> 的值，而不会
将求值计算延缓到变量 C<$b> 实际被读取时。

