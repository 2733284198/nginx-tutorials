= Nginx 配置指令的执行顺序（一） =

大多数 Nginx 新手都会频繁遇到这样一个困惑，那就是在 Nginx 配置中如
何同时使用到了多个 Nginx 模块提供的配置指令，这些配置指令的实际执行顺序会
跟它们在配置文件中的书写顺序大相径庭。于是许多人选择了“试错法”，他们的配置文件
经常被改得一片狼藉。这个系列的教程就旨在帮助读者理解这些配置指令背后的执行时间和
先后顺序。

我们现在就来看这样一个令人困惑的有问题的例子：

    :nginx
    ? location /test {
    ?     set $a 32;
    ?     echo $a;
    ?
    ?     set $a 56;
    ?     echo $a;
    ? }

从这个例子表面上的意思来看，我们期望的输出是一行 C<32> 和一行 C<56>，
因为我们第一次用 L<ngx_echo/echo> 配置指令输出了 C<$a>
变量的值以后，又紧接着使用 C<ngx_rewrite/set> 配置指令修改了
C<$a>. 然后不幸地是，事实并非如此：

    :bash
    $ curl 'http://localhost:8080/test
    56
    56

我们看到，语句 C<set $a 56> 似乎在第一条 C<echo $a> 语
句之前就执行过了。这究竟是为什么呢？难道我们遇到了 Nginx 的一个 bug？

显然，这里并没有遇见 Nginx 的 bug. 要理解这里发生的事情，就需要首先
知道 Nginx 处理每一个用户请求的时候，都是按若干个不同阶段（phase）来
处理的。Nginx 的请求处理阶段一共有十一个之多，其中三个最为常见的，按照它们
执行时的先后顺序，依次是 C<rewrite> 阶段，C<access> 阶段，
以及 C<content> 阶段（后面我们还会见到其他更多的处理阶段）。

所有 Nginx 模块提供的配置指令一般只会注册并运行在其中的某一个处理阶段。比
如上例中的 L<ngx_rewrite/set> 指令就是在 C<rewrite>
阶段运行的，而 L<ngx_echo/echo> 配置指令就只会在 C<content>
阶段运行。前面我们已经知道，在单个请求的处理过程中，C<rewrite> 阶段总
是在 C<content> 阶段之前执行，因此属于 C<rewrite> 阶段的
配置指令也总是会无条件地在 C<content> 阶段的配置指令之前执行。因此，
在同一个 C<location> 配置块中，L<ngx_rewrite/set>
指令总是会在 L<ngx_echo/echo> 指令之前执行，即使我们把 L<ngx_rewrite/set>
语句写在了 L<ngx_echo/echo> 语句的后面。

回到刚才那个例子，

    :nginx
    set $a 32;
    echo $a;

    set $a 56;
    echo $a;

实际的执行顺序应当是

    :nginx
    set $a 32;
    set $a 56;
    echo $a;
    echo $a;

即先在 C<rewrite> 阶段执行完我们这里的两条 L<ngx_rewrite/set>
赋值语句，然后再在后面的 C<content> 阶段依次执行我们的两条 L<ngx_echo/echo>
语句。

为了进一步验证这一点，我们不妨借助一下 Nginx 的“调试日志”来简单一窥
Nginx 的实际执行过程。

因为这是我们第一次提及 Nginx 的调试日志，所以有必要先简单介绍一下它的启用
方法。调试日志默认是禁用的，因为它会引入比较大的运行时开销，让 Nginx 服务
器显著变慢。一般我们需要重新编译和构造 Nginx 可执行文件，并且在调用 Nginx
源码包提供的 C<./configure> 脚本时传入 C<--with-debug>
命令行选项，例如我们在下载完 Nginx 源码包后在 Linux 或者 Mac
OS X 系统上典型的构建步骤是这样的：

    :bash
    tar xvf nginx-1.0.10.tar.gz
    cd nginx-1.0.10/
    ./configure --with-debug
    make
    sudu make install

如果你使用的是我维护的 C<ngx_openresty> 软件包，则同样可以向
C<./configure> 脚本传递 C<--with-debug> 命令行选
项，与上面的步骤几乎完全相同。

当我们启用 C<--with-debug> 选项重新构建好调试版的 Nginx
之后，我们还需要同时在 Nginx 配置文件 F<nginx.conf> 中为错
误日志使用 C<debug> 日志级别：

    :nginx
    error_log logs/error.log debug;

这里重要的是第二个 C<debug> 参数，而前面的第一个参数是我们的错误日志的
路径，F<logs/error.log>，当然你也可以选择某个其他的路径。但后面
我们会检查 Nginx 输出到这个错误日志文件的内容，所以请注意这里配置的文件路
径。

现在我们重新启动 Nginx（注意，如果 Nginx 可执行文件也被更新过，仅仅
让 Nginx 重新加载配置是不够的，需要真正意义上的关闭和重启过程）。再请求一
下我们的那个示例接口：

    :bash
    $ curl 'http://localhost:8080/test'
    56
    56

然后我们可以检查一下前面配置的 Nginx 错误日志文件中的输出。因为文件中的输
出比较多，在我的机器上有近千行，所以我们不妨用 C<grep> 命令在终端上过滤
一下我们最感兴趣的那几行：

    :bash
    grep -E 'http (output filter|script (set|value))' logs/error.log

输出应该是这个样子的（为了方便放到这里，我们对 C<grep> 命令的实际输出作
了一下简单的编辑，略去了行首的时间戳）：

    :text
    [debug] 5363#0: *1 http script value: "32"
    [debug] 5363#0: *1 http script set $a
    [debug] 5363#0: *1 http script value: "56"
    [debug] 5363#0: *1 http script set $a
    [debug] 5363#0: *1 http output filter "/test?"
    [debug] 5363#0: *1 http output filter "/test?"
    [debug] 5363#0: *1 http output filter "/test?"

这里需要稍微解释一下。L<ngx_rewrite/set> 配置指令在实际运行时
会打印出两行以 C<http script> 起始的调试信息，其中第一行信息是
L<ngx_rewrite/set> 语句中被赋予的值，而第二行则是 L<ngx_rewrite/set>
语句中被赋值的 Nginx 变量名。于是上面首先过滤出来的

    :text
    [debug] 5363#0: *1 http script value: "32"
    [debug] 5363#0: *1 http script set $a

这两行就对应我们例子中的

    :nginx
    set $a 32;

这一行，而

    :text
    [debug] 5363#0: *1 http script value: "56"
    [debug] 5363#0: *1 http script set $a

则对应配置

    :nginx
    set $a 56

此外，凡在 Nginx 中输出响应体的数据时，一般都会调用 Nginx 的所谓“
输出过滤器”（output filter），我们一直在使用的 L<ngx_echo/echo>
指令自然也不例外。而一旦调用 Nginx 的“输出过滤器”，便会产生类似下面这样
的调试信息：

    :text
    [debug] 5363#0: *1 http output filter "/test?"

当然，这里的 C<"/test?"> 部分可能会发生变化，因为它显示的是当前请求
的 URI. 这样连起来看，我们就不难发现，我们的两条 L<ngx_rewrite/set>
语句确实都在两条 L<ngx_echo/echo> 语句之前执行的。

细心的读者可能会问，为什么我们这个例子明明只使用了两条 L<ngx_echo/echo>
语句输出
，为什么会有三行 C<http output filter> 调试信息呢？其实前
两行 C<http output filter> 输出确实分别对应我们的那两条
L<ngx_echo/echo> 语句，而最后那行则是用于输出指示响应体末尾的结
束标记，所以才会多出一次对 Nginx “输出过滤器”的调用。

